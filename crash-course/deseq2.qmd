---
title: deseq2
format: html
---

::: callout-note
This document takes examples from the [DESeq2 Vignette](https://www.bioconductor.org/packages/release/bioc/vignettes/DESeq2/inst/doc/DESeq2.html). This is by no means a comprehensive guide!
:::

## Workspace Setup

If you have not yet installed `DESeq2`, please do so for this walk through. We will also be using data from [pasilla](https://bioconductor.org/packages/release/data/experiment/html/pasilla.html), which is a Drosophila dataset.

```{r}
#| eval: false

if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

BiocManager::install("pasilla")
BiocManager::install("DESeq2")
BiocManager::install("apeglm")
BiocManager::install("pheatmap")
install.packages("tidyverse")
```


## Data Import

We will start by finding the data packaged with the `pasilla` package. Accessing data within a package uses the `system.file()` function. If a package also contains a readable dataset from disk, it is conventionally, stored within a sub-directory of that package called `extdata/`. The `system.file()` function makes it easy to find these files.

```{r}
#| message: false
#| warning: false
library(DESeq2)
library(tidyverse)
```

```{r}
#| echo: false

# just here for renv to pick up
invisible(apeglm::apeglm)
invisible(pasilla:::.__NAMESPACE__.)
```


```{r}
pasCts <- system.file("extdata",
                      "pasilla_gene_counts.tsv",
                      package="pasilla", mustWork=TRUE)
pasAnno <- system.file("extdata",
                       "pasilla_sample_annotation.csv",
                       package="pasilla", mustWork=TRUE)
cts <- as.matrix(read.csv(pasCts,sep="\t",row.names="gene_id"))
coldata <- read.csv(pasAnno, row.names=1)
coldata <- coldata[,c("condition","type")]
coldata$condition <- factor(coldata$condition)
coldata$type <- factor(coldata$type)
```

### Data Inspection

As programmers, we must always be thinking about where our data comes from and how to structure the data. Browsing through BioConductor, we find the following information about the `pasilla` package.

> Data package with per-exon and per-gene read counts of RNA-seq samples of Pasilla knock-down by Brooks et al., Genome Research 2011.

So lets inspect the data and see if this makes sense!

::: {.callout-important collapse="true"} 
The data we loaded has already been processed from the instrument output. Loosely speaking, we are working on the **downstream** portion of our analysis pipeline.

If you have raw sequencing files (`.bam/.fastq/.h5`), you may still need to process these files into "raw counts" or whatever **downstream** data output that R can handle for analysis. 
:::

```{r}
dim(cts)
cts[1:10,]
coldata
```

The data seems simple enough!

#### The SummarizedExperiment Class

Before we continue, lets get an idea of the kind of data structure we will be working with. `DESeq2` objects extend a common data structure from BioConductor called a `SummarizedExperiment`. Below is the general structure of the object.

![From BioConductor,[SummarizedExperiment Vignette](https://www.bioconductor.org/packages/devel/bioc/vignettes/SummarizedExperiment/inst/doc/SummarizedExperiment.html)](./SE.png)

::: {.callout-note collapse="true" title="`tidyverse` vs `BioConductor`"}
This convention is different from that of the `tidyverse` whose functions tend to operate on `data.frame` objects. The `SummarizedExperiment` object is a compressed form of data. 
:::

```{r}
rbind(
  colnames(cts),
  rownames(coldata)
)
```

::: {.callout-important}
They do not match and they are not in order! Consider using lessons from [class 5-6](../class1.qmd)
:::

```{r}
rownames(coldata) <- sub("fb", "", rownames(coldata))
coldata <- coldata[colnames(cts),]
# check again visually
rbind(
  colnames(cts),
  rownames(coldata)
)
```

::: {.callout-warning collapse="true" title="Challenge"}
We rearranged our data so that we could gaurentee that they would be in the correct order. We "verified" this visually. **Can you write up a way to check that the two name vectors are in order, without visually checking?**
Consider our discussions on Logical Operators and `all()` or `any()`. 
Don't forget to check your help documentation!
:::

### The **D**ESeq**D**ata**S**et (dds)

Now that our data is ordered we are almost ready to use `DESeq2`. We should first recall what is the goal of our experimental analysis. `DESeq2` is intended to **compare** experimental conditions effect on transcription counts. Thus in doing so, we are required to specify our model __design__ with `DESeq2`.

::: {.callout-note collapse="true" title="Model Designs in R"}
R represents modeling with `~`. You may see this in the following forms:

- `y ~ x`
- `  ~ x`

The style used generally depends on the function.
:::

```{r}
count(coldata, condition)
```

```{r}
coldata$condition <- factor(
  coldata$condition,
  levels = c("untreated", "treated")) 
dds <- DESeqDataSetFromMatrix(
  countData = cts,
  colData = coldata,
  design = ~ condition # indicating we are testing between
)

# not necessary, just to put something here
rowData(dds)$gene <- rownames(dds)

dds
```

#### The Most Important Commands

```{r}
dds_out <- DESeq(dds)

res <- results(dds_out)
res
```

::: callout-tip
Congratulations! You have completed you first Differential Expression RNAseq Analysis! 
:::

### LFC Shrinkage

[Shrinkage](https://en.wikipedia.org/wiki/Shrinkage_(statistics)) in the world of statistics generally means to reduce variance in our parameter estimations. The Log Fold Change we calculate between these two groups are based on sample sizes 3 and 4 for 14,000 different Genes. This isn't too many samples to get a sense of the underlying distribution. Thus shrinkage will help reduce variation in samples that may be large by pure chance.

```{r}
res_shrink <- lfcShrink(
  dds_out,
  coef="condition_treated_vs_untreated",
  type="apeglm")

res_shrink
```

::: {.callout-warning collapse="true" title="Challenge"}
See if you can compare the LFG values between `res` and `res_shrink`. Are they smaller? larger?
See if you can create a scatter plot between these two vectors.

> for an easy plot, consider `plot(x, y)` where x is the LFG in one result, and y is the LFG in the other result

:::

### Plotting

#### MA plot

```{r}
# alpha is set to 0.1 by default
plotMA(res, ylim = c(-2, 2))
plotMA(res, ylim = c(-2, 2), alpha = .01)
plotMA(res_shrink, ylim = c(-2, 2), alpha = .0001)
```

::: {.callout-note title="Significance Values"}

The `alpha` threshold for declaring significance can feel arbitrary at times. This is likely the largest criticism from Bayesian statisticians.

We will not cover theory on power estimations for reasonable `alpha` thresholds. This value should however be decided on ahead of time (ideally when planning the experiment's design!)

:::


##### Saving output

Lets assume that we settled on a `alpha` threshold of `0.0001` for this data and we intend to use the shrunk results. Lets subset this data and write that to disk!

```{r}
res_subset <- res_shrink %>%
  as_tibble(rownames = "gene") %>%
  filter(padj < 0.0001 & !is.na(padj))
```


```{r}
#| eval: false
write.csv(res_subset, "deseq2-sig-results.csv")
```

#### Heatmap

```{r}
library(pheatmap)
```


For visualizing data in a heatmap, it may not be very effective to show the raw counts as some genes may have very low counts, and others may have 10s of thousands. For this reason we may visualize data with a transformation. `DESeq2` has a function called `vst()` (variance stabalizing transform) that we can call on a `dds` object.

```{r}
dds_out_vst <- vst(dds_out)
dds_out_vst_sub <- dds_out_vst[rownames(dds) %in% res_subset$gene,]
pheatmap(assay(dds_out_vst_sub), cluster_rows = TRUE,
         show_rownames = FALSE,
         annotation_col = as.data.frame(colData(dds_out_vst_sub)[,c("condition","type")])
         )
```

Alternatively a quick solution is to push our data through a log transform

```{r}
dds_sub <- dds_out[rownames(dds) %in% res_subset$gene,]
assays(dds_sub)$log <- log10(assay(dds_sub))
pheatmap::pheatmap(assay(dds_sub, "log"), cluster_rows = TRUE,
         show_rownames = FALSE,
         annotation_col = as.data.frame(colData(dds_sub)[,c("condition","type")])
         )
```

#### PCA

Similarly we generally use transformed/scaled values for PCA as extremely large values will dominate the variance we may want to capture.

```{r}
plotPCA(dds_out_vst) +
  theme_classic()

plotPCA(dds_out_vst_sub) +
  theme_classic()
```

::: {.callout-note title="Note for PCA"}
PCA is very sensitive to the data provided. In other words, the resulting dimensions may change drastically 
:::
